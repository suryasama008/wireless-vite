import {
  _inheritsLoose,
  init_inheritsLoose
} from "./chunk-TU577VYH.js";
import {
  require_leaflet_src
} from "./chunk-AVTUJHON.js";
import {
  require_warning
} from "./chunk-YSAUMPS4.js";
import {
  require_hoist_non_react_statics_cjs
} from "./chunk-OH2OWROH.js";
import {
  require_react_dom
} from "./chunk-AGYRAQNY.js";
import {
  _extends,
  init_extends
} from "./chunk-SUFR5NQW.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-EBW3JKEH.js";
import "./chunk-VGPEVICO.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";
import {
  _assertThisInitialized,
  init_assertThisInitialized
} from "./chunk-6SNKQ5Q3.js";
import "./chunk-AZHVXIJD.js";
import {
  _createClass
} from "./chunk-VPHLUJNF.js";
import {
  require_fast_deep_equal
} from "./chunk-Y3Z6YDLT.js";
import {
  require_react
} from "./chunk-KL6BCPSF.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/react-leaflet/es/context.js
init_extends();
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_react = __toESM(require_react());
var leafletContext = (0, import_react.createContext)({});
var useLeaflet = function useLeaflet2() {
  return (0, import_react.useContext)(leafletContext);
};
var LeafletConsumer = leafletContext.Consumer;
var LeafletProvider = leafletContext.Provider;
var withLeaflet = function withLeaflet2(WrappedComponent) {
  var WithLeafletComponent = function WithLeafletComponent2(props, ref) {
    return import_react.default.createElement(LeafletConsumer, null, function(leaflet) {
      return import_react.default.createElement(WrappedComponent, _extends({}, props, {
        leaflet,
        ref
      }));
    });
  };
  var name = WrappedComponent.displayName || WrappedComponent.name || "Component";
  WithLeafletComponent.displayName = "Leaflet(" + name + ")";
  var LeafletComponent = (0, import_react.forwardRef)(WithLeafletComponent);
  (0, import_hoist_non_react_statics.default)(LeafletComponent, WrappedComponent);
  return LeafletComponent;
};

// node_modules/react-leaflet/es/AttributionControl.js
init_inheritsLoose();
var import_leaflet2 = __toESM(require_leaflet_src());

// node_modules/react-leaflet/es/MapControl.js
init_assertThisInitialized();
init_inheritsLoose();
var import_leaflet = __toESM(require_leaflet_src());
var import_react2 = __toESM(require_react());
var MapControl = function(_Component) {
  _inheritsLoose(MapControl2, _Component);
  function MapControl2(props) {
    var _this;
    _this = _Component.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this), "leafletElement", void 0);
    _this.leafletElement = _this.createLeafletElement(_this.props);
    return _this;
  }
  var _proto = MapControl2.prototype;
  _proto.createLeafletElement = function createLeafletElement(_props) {
    throw new Error("createLeafletElement() must be implemented");
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.position !== fromProps.position) {
      this.leafletElement.setPosition(toProps.position);
    }
  };
  _proto.componentDidMount = function componentDidMount() {
    this.leafletElement.addTo(this.props.leaflet.map);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    this.updateLeafletElement(prevProps, this.props);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.leafletElement.remove();
  };
  _proto.render = function render() {
    return null;
  };
  return MapControl2;
}(import_react2.Component);

// node_modules/react-leaflet/es/AttributionControl.js
var AttributionControl = function(_MapControl) {
  _inheritsLoose(AttributionControl2, _MapControl);
  function AttributionControl2() {
    return _MapControl.apply(this, arguments) || this;
  }
  var _proto = AttributionControl2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet2.Control.Attribution(props);
  };
  return AttributionControl2;
}(MapControl);
var AttributionControl_default = withLeaflet(AttributionControl);

// node_modules/react-leaflet/es/Circle.js
init_objectWithoutPropertiesLoose();
init_inheritsLoose();
var import_leaflet3 = __toESM(require_leaflet_src());

// node_modules/react-leaflet/es/Path.js
init_extends();
init_inheritsLoose();
var import_fast_deep_equal = __toESM(require_fast_deep_equal());

// node_modules/react-leaflet/es/MapLayer.js
init_assertThisInitialized();
init_inheritsLoose();
var import_react4 = __toESM(require_react());

// node_modules/react-leaflet/es/MapComponent.js
init_extends();
init_inheritsLoose();

// node_modules/react-leaflet/es/MapEvented.js
init_extends();
init_assertThisInitialized();
init_inheritsLoose();
var import_react3 = __toESM(require_react());
var EVENTS_RE = /^on(.+)$/i;
var MapEvented = function(_Component) {
  _inheritsLoose(MapEvented2, _Component);
  function MapEvented2(props) {
    var _this;
    _this = _Component.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this), "_leafletEvents", void 0);
    _defineProperty(_assertThisInitialized(_this), "leafletElement", void 0);
    _this._leafletEvents = _this.extractLeafletEvents(props);
    return _this;
  }
  var _proto = MapEvented2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.bindLeafletEvents(this._leafletEvents);
  };
  _proto.componentDidUpdate = function componentDidUpdate(_prevProps) {
    this._leafletEvents = this.bindLeafletEvents(this.extractLeafletEvents(this.props), this._leafletEvents);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this2 = this;
    var el = this.leafletElement;
    if (!el)
      return;
    Object.keys(this._leafletEvents).forEach(function(ev) {
      el.off(ev, _this2._leafletEvents[ev]);
    });
  };
  _proto.extractLeafletEvents = function extractLeafletEvents(props) {
    return Object.keys(props).reduce(function(res, prop) {
      if (EVENTS_RE.test(prop)) {
        if (props[prop] != null) {
          var _key = prop.replace(EVENTS_RE, function(match, p) {
            return p.toLowerCase();
          });
          res[_key] = props[prop];
        }
      }
      return res;
    }, {});
  };
  _proto.bindLeafletEvents = function bindLeafletEvents(next, prev) {
    if (next === void 0) {
      next = {};
    }
    if (prev === void 0) {
      prev = {};
    }
    var el = this.leafletElement;
    if (el == null || el.on == null)
      return {};
    var diff = _extends({}, prev);
    Object.keys(prev).forEach(function(ev) {
      if (next[ev] == null || prev[ev] !== next[ev]) {
        delete diff[ev];
        el.off(ev, prev[ev]);
      }
    });
    Object.keys(next).forEach(function(ev) {
      if (prev[ev] == null || next[ev] !== prev[ev]) {
        diff[ev] = next[ev];
        el.on(ev, next[ev]);
      }
    });
    return diff;
  };
  _proto.fireLeafletEvent = function fireLeafletEvent(type, data) {
    var el = this.leafletElement;
    if (el)
      el.fire(type, data);
  };
  return MapEvented2;
}(import_react3.Component);

// node_modules/react-leaflet/es/MapComponent.js
var MapComponent = function(_MapEvented) {
  _inheritsLoose(MapComponent2, _MapEvented);
  function MapComponent2() {
    return _MapEvented.apply(this, arguments) || this;
  }
  var _proto = MapComponent2.prototype;
  _proto.getOptions = function getOptions(props) {
    if (props.pane != null) {
      return props;
    }
    if (props.leaflet != null && props.leaflet.pane != null) {
      return _extends({}, props, {
        pane: props.leaflet.pane
      });
    }
    return props;
  };
  return MapComponent2;
}(MapEvented);

// node_modules/react-leaflet/es/MapLayer.js
var MapLayer = function(_MapComponent) {
  _inheritsLoose(MapLayer2, _MapComponent);
  function MapLayer2(props) {
    var _this;
    _this = _MapComponent.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this), "contextValue", void 0);
    _defineProperty(_assertThisInitialized(_this), "leafletElement", void 0);
    _this.leafletElement = _this.createLeafletElement(props);
    return _this;
  }
  var _proto = MapLayer2.prototype;
  _proto.createLeafletElement = function createLeafletElement(_props) {
    throw new Error("createLeafletElement() must be implemented");
  };
  _proto.updateLeafletElement = function updateLeafletElement(_fromProps, _toProps) {
  };
  _proto.componentDidMount = function componentDidMount() {
    _MapComponent.prototype.componentDidMount.call(this);
    this.layerContainer.addLayer(this.leafletElement);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    _MapComponent.prototype.componentDidUpdate.call(this, prevProps);
    if (this.props.attribution !== prevProps.attribution) {
      var map = this.props.leaflet.map;
      if (map != null && map.attributionControl != null) {
        map.attributionControl.removeAttribution(prevProps.attribution);
        map.attributionControl.addAttribution(this.props.attribution);
      }
    }
    this.updateLeafletElement(prevProps, this.props);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    _MapComponent.prototype.componentWillUnmount.call(this);
    this.layerContainer.removeLayer(this.leafletElement);
  };
  _proto.render = function render() {
    var children = this.props.children;
    if (children == null) {
      return null;
    }
    return this.contextValue == null ? import_react4.default.createElement(import_react4.Fragment, null, children) : import_react4.default.createElement(LeafletProvider, {
      value: this.contextValue
    }, children);
  };
  _createClass(MapLayer2, [{
    key: "layerContainer",
    get: function get() {
      return this.props.leaflet.layerContainer || this.props.leaflet.map;
    }
  }]);
  return MapLayer2;
}(MapComponent);

// node_modules/react-leaflet/es/utils/pick.js
function pick(object, keys) {
  return keys.reduce(function(obj, key) {
    if (typeof object[key] !== "undefined") {
      obj[key] = object[key];
    }
    return obj;
  }, {});
}

// node_modules/react-leaflet/es/Path.js
var OPTIONS = [
  "stroke",
  "color",
  "weight",
  "opacity",
  "lineCap",
  "lineJoin",
  "dashArray",
  "dashOffset",
  "fill",
  "fillColor",
  "fillOpacity",
  "fillRule",
  "bubblingMouseEvents",
  "renderer",
  "className",
  "interactive",
  "pane",
  "attribution"
];
var Path = function(_MapLayer) {
  _inheritsLoose(Path2, _MapLayer);
  function Path2(props) {
    var _this;
    _this = _MapLayer.call(this, props) || this;
    if (_this.contextValue == null) {
      _this.contextValue = _extends({}, props.leaflet, {
        popupContainer: _this.leafletElement
      });
    }
    return _this;
  }
  var _proto = Path2.prototype;
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    _MapLayer.prototype.componentDidUpdate.call(this, prevProps);
    this.setStyleIfChanged(prevProps, this.props);
  };
  _proto.getPathOptions = function getPathOptions(props) {
    return pick(props, OPTIONS);
  };
  _proto.setStyle = function setStyle(options) {
    if (options === void 0) {
      options = {};
    }
    this.leafletElement.setStyle(options);
  };
  _proto.setStyleIfChanged = function setStyleIfChanged(fromProps, toProps) {
    var nextStyle = this.getPathOptions(toProps);
    if (!(0, import_fast_deep_equal.default)(nextStyle, this.getPathOptions(fromProps))) {
      this.setStyle(nextStyle);
    }
  };
  return Path2;
}(MapLayer);

// node_modules/react-leaflet/es/Circle.js
var Circle = function(_Path) {
  _inheritsLoose(Circle2, _Path);
  function Circle2() {
    return _Path.apply(this, arguments) || this;
  }
  var _proto = Circle2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var center = props.center, radius = props.radius, options = _objectWithoutPropertiesLoose(props, ["center", "radius"]);
    return new import_leaflet3.Circle(center, radius, this.getOptions(options));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.center !== fromProps.center) {
      this.leafletElement.setLatLng(toProps.center);
    }
    if (toProps.radius !== fromProps.radius) {
      this.leafletElement.setRadius(toProps.radius);
    }
  };
  return Circle2;
}(Path);
var Circle_default = withLeaflet(Circle);

// node_modules/react-leaflet/es/CircleMarker.js
init_extends();
init_inheritsLoose();
var import_leaflet4 = __toESM(require_leaflet_src());
var CircleMarker = function(_Path) {
  _inheritsLoose(CircleMarker2, _Path);
  function CircleMarker2() {
    return _Path.apply(this, arguments) || this;
  }
  var _proto = CircleMarker2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var el = new import_leaflet4.CircleMarker(props.center, this.getOptions(props));
    this.contextValue = _extends({}, props.leaflet, {
      popupContainer: el
    });
    return el;
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.center !== fromProps.center) {
      this.leafletElement.setLatLng(toProps.center);
    }
    if (toProps.radius !== fromProps.radius) {
      this.leafletElement.setRadius(toProps.radius);
    }
  };
  return CircleMarker2;
}(Path);
var CircleMarker_default = withLeaflet(CircleMarker);

// node_modules/react-leaflet/es/DivOverlay.js
init_assertThisInitialized();
init_inheritsLoose();
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-leaflet/es/utils/updateClassName.js
var import_leaflet5 = __toESM(require_leaflet_src());
var splitClassName = function splitClassName2(className) {
  if (className === void 0) {
    className = "";
  }
  return className.split(" ").filter(Boolean);
};
var addClassName = function addClassName2(container, className) {
  splitClassName(className).forEach(function(cls) {
    import_leaflet5.DomUtil.addClass(container, cls);
  });
};
var removeClassName = function removeClassName2(container, className) {
  splitClassName(className).forEach(function(cls) {
    import_leaflet5.DomUtil.removeClass(container, cls);
  });
};
var updateClassName_default = function(container, prevClassName, nextClassName) {
  if (container != null && nextClassName !== prevClassName) {
    if (prevClassName != null && prevClassName.length > 0) {
      removeClassName(container, prevClassName);
    }
    if (nextClassName != null && nextClassName.length > 0) {
      addClassName(container, nextClassName);
    }
  }
};

// node_modules/react-leaflet/es/DivOverlay.js
var DivOverlay = function(_MapComponent) {
  _inheritsLoose(DivOverlay2, _MapComponent);
  function DivOverlay2(props) {
    var _this;
    _this = _MapComponent.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this), "onClose", function() {
      if (_this.props.onClose) {
        _this.props.onClose();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onOpen", function() {
      _this.forceUpdate();
      if (_this.props.onOpen) {
        _this.props.onOpen();
      }
    });
    _this.leafletElement = _this.createLeafletElement(props);
    return _this;
  }
  var _proto = DivOverlay2.prototype;
  _proto.createLeafletElement = function createLeafletElement(_props) {
    throw new Error("createLeafletElement() must be implemented");
  };
  _proto.updateLeafletElement = function updateLeafletElement(_prevProps, _props) {
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    updateClassName_default(this.leafletElement._container, prevProps.className, this.props.className);
    this.updateLeafletElement(prevProps, this.props);
    if (this.leafletElement.isOpen()) {
      this.leafletElement.update();
      this.onRender();
    }
  };
  _proto.onRender = function onRender() {
  };
  _proto.render = function render() {
    if (this.leafletElement._contentNode) {
      return (0, import_react_dom.createPortal)(this.props.children, this.leafletElement._contentNode);
    }
    return null;
  };
  return DivOverlay2;
}(MapComponent);

// node_modules/react-leaflet/es/FeatureGroup.js
init_extends();
init_inheritsLoose();
var import_leaflet6 = __toESM(require_leaflet_src());
var FeatureGroup = function(_Path) {
  _inheritsLoose(FeatureGroup2, _Path);
  function FeatureGroup2() {
    return _Path.apply(this, arguments) || this;
  }
  var _proto = FeatureGroup2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var el = new import_leaflet6.FeatureGroup(this.getOptions(props));
    this.contextValue = _extends({}, props.leaflet, {
      layerContainer: el,
      popupContainer: el
    });
    return el;
  };
  _proto.componentDidMount = function componentDidMount() {
    _Path.prototype.componentDidMount.call(this);
    this.setStyle(this.props);
  };
  return FeatureGroup2;
}(Path);
var FeatureGroup_default = withLeaflet(FeatureGroup);

// node_modules/react-leaflet/es/GeoJSON.js
init_inheritsLoose();
var import_leaflet7 = __toESM(require_leaflet_src());
var GeoJSON = function(_Path) {
  _inheritsLoose(GeoJSON2, _Path);
  function GeoJSON2() {
    return _Path.apply(this, arguments) || this;
  }
  var _proto = GeoJSON2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet7.GeoJSON(props.data, this.getOptions(props));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (typeof toProps.style === "function") {
      this.leafletElement.setStyle(toProps.style);
    } else {
      this.setStyleIfChanged(fromProps, toProps);
    }
  };
  return GeoJSON2;
}(Path);
var GeoJSON_default = withLeaflet(GeoJSON);

// node_modules/react-leaflet/es/GridLayer.js
init_extends();
init_inheritsLoose();
var import_leaflet8 = __toESM(require_leaflet_src());
var GridLayer = function(_MapLayer) {
  _inheritsLoose(GridLayer2, _MapLayer);
  function GridLayer2() {
    return _MapLayer.apply(this, arguments) || this;
  }
  var _proto = GridLayer2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet8.GridLayer(this.getOptions(props));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    var opacity = toProps.opacity, zIndex = toProps.zIndex;
    if (opacity !== fromProps.opacity) {
      this.leafletElement.setOpacity(opacity);
    }
    if (zIndex !== fromProps.zIndex) {
      this.leafletElement.setZIndex(zIndex);
    }
  };
  _proto.getOptions = function getOptions(props) {
    var options = _extends({}, _MapLayer.prototype.getOptions.call(this, props));
    var map = props.leaflet.map;
    if (map != null) {
      if (options.maxZoom == null && map.options.maxZoom != null) {
        options.maxZoom = map.options.maxZoom;
      }
      if (options.minZoom == null && map.options.minZoom != null) {
        options.minZoom = map.options.minZoom;
      }
    }
    return options;
  };
  _proto.render = function render() {
    return null;
  };
  return GridLayer2;
}(MapLayer);

// node_modules/react-leaflet/es/ImageOverlay.js
init_extends();
init_inheritsLoose();
var import_leaflet9 = __toESM(require_leaflet_src());
var ImageOverlay = function(_MapLayer) {
  _inheritsLoose(ImageOverlay2, _MapLayer);
  function ImageOverlay2() {
    return _MapLayer.apply(this, arguments) || this;
  }
  var _proto = ImageOverlay2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var el = new import_leaflet9.ImageOverlay(props.url, props.bounds, this.getOptions(props));
    this.contextValue = _extends({}, props.leaflet, {
      popupContainer: el
    });
    return el;
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.url !== fromProps.url) {
      this.leafletElement.setUrl(toProps.url);
    }
    if (toProps.bounds !== fromProps.bounds) {
      this.leafletElement.setBounds((0, import_leaflet9.latLngBounds)(toProps.bounds));
    }
    if (toProps.opacity !== fromProps.opacity) {
      this.leafletElement.setOpacity(toProps.opacity);
    }
    if (toProps.zIndex !== fromProps.zIndex) {
      this.leafletElement.setZIndex(toProps.zIndex);
    }
  };
  return ImageOverlay2;
}(MapLayer);
var ImageOverlay_default = withLeaflet(ImageOverlay);

// node_modules/react-leaflet/es/LayerGroup.js
init_extends();
init_inheritsLoose();
var import_leaflet10 = __toESM(require_leaflet_src());
var LayerGroup = function(_MapLayer) {
  _inheritsLoose(LayerGroup2, _MapLayer);
  function LayerGroup2() {
    return _MapLayer.apply(this, arguments) || this;
  }
  var _proto = LayerGroup2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var el = new import_leaflet10.LayerGroup([], this.getOptions(props));
    this.contextValue = _extends({}, props.leaflet, {
      layerContainer: el
    });
    return el;
  };
  return LayerGroup2;
}(MapLayer);
var LayerGroup_default = withLeaflet(LayerGroup);

// node_modules/react-leaflet/es/LayersControl.js
init_objectWithoutPropertiesLoose();
init_extends();
init_assertThisInitialized();
init_inheritsLoose();
var import_leaflet11 = __toESM(require_leaflet_src());
var import_react5 = __toESM(require_react());
var ControlledLayer = function(_Component) {
  _inheritsLoose(ControlledLayer2, _Component);
  function ControlledLayer2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _defineProperty(_assertThisInitialized(_this), "contextValue", void 0);
    _defineProperty(_assertThisInitialized(_this), "layer", void 0);
    return _this;
  }
  var _proto = ControlledLayer2.prototype;
  _proto.componentDidUpdate = function componentDidUpdate(_ref) {
    var checked = _ref.checked;
    if (this.props.leaflet.map == null) {
      return;
    }
    if (this.props.checked === true && (checked == null || checked === false)) {
      this.props.leaflet.map.addLayer(this.layer);
    } else if (checked === true && (this.props.checked == null || this.props.checked === false)) {
      this.props.leaflet.map.removeLayer(this.layer);
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.removeLayerControl(this.layer);
  };
  _proto.addLayer = function addLayer() {
    throw new Error("Must be implemented in extending class");
  };
  _proto.removeLayer = function removeLayer(layer) {
    this.props.removeLayer(layer);
  };
  _proto.render = function render() {
    var children = this.props.children;
    return children ? import_react5.default.createElement(LeafletProvider, {
      value: this.contextValue
    }, children) : null;
  };
  return ControlledLayer2;
}(import_react5.Component);
var BaseLayer = function(_ControlledLayer) {
  _inheritsLoose(BaseLayer2, _ControlledLayer);
  function BaseLayer2(props) {
    var _this2;
    _this2 = _ControlledLayer.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this2), "addLayer", function(layer) {
      _this2.layer = layer;
      var _this2$props = _this2.props, addBaseLayer = _this2$props.addBaseLayer, checked = _this2$props.checked, name = _this2$props.name;
      addBaseLayer(layer, name, checked);
    });
    _this2.contextValue = _extends({}, props.leaflet, {
      layerContainer: {
        addLayer: _this2.addLayer.bind(_assertThisInitialized(_this2)),
        removeLayer: _this2.removeLayer.bind(_assertThisInitialized(_this2))
      }
    });
    return _this2;
  }
  return BaseLayer2;
}(ControlledLayer);
var Overlay = function(_ControlledLayer2) {
  _inheritsLoose(Overlay2, _ControlledLayer2);
  function Overlay2(props) {
    var _this3;
    _this3 = _ControlledLayer2.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this3), "addLayer", function(layer) {
      _this3.layer = layer;
      var _this3$props = _this3.props, addOverlay = _this3$props.addOverlay, checked = _this3$props.checked, name = _this3$props.name;
      addOverlay(layer, name, checked);
    });
    _this3.contextValue = _extends({}, props.leaflet, {
      layerContainer: {
        addLayer: _this3.addLayer.bind(_assertThisInitialized(_this3)),
        removeLayer: _this3.removeLayer.bind(_assertThisInitialized(_this3))
      }
    });
    return _this3;
  }
  return Overlay2;
}(ControlledLayer);
var LayersControl = function(_MapControl) {
  _inheritsLoose(LayersControl2, _MapControl);
  function LayersControl2(props) {
    var _this4;
    _this4 = _MapControl.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this4), "controlProps", void 0);
    _this4.controlProps = {
      addBaseLayer: _this4.addBaseLayer.bind(_assertThisInitialized(_this4)),
      addOverlay: _this4.addOverlay.bind(_assertThisInitialized(_this4)),
      leaflet: props.leaflet,
      removeLayer: _this4.removeLayer.bind(_assertThisInitialized(_this4)),
      removeLayerControl: _this4.removeLayerControl.bind(_assertThisInitialized(_this4))
    };
    return _this4;
  }
  var _proto2 = LayersControl2.prototype;
  _proto2.createLeafletElement = function createLeafletElement(props) {
    var _children = props.children, options = _objectWithoutPropertiesLoose(props, ["children"]);
    return new import_leaflet11.Control.Layers(void 0, void 0, options);
  };
  _proto2.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    _MapControl.prototype.updateLeafletElement.call(this, fromProps, toProps);
    if (toProps.collapsed !== fromProps.collapsed) {
      if (toProps.collapsed === true) {
        this.leafletElement.collapse();
      } else {
        this.leafletElement.expand();
      }
    }
  };
  _proto2.componentWillUnmount = function componentWillUnmount() {
    var _this5 = this;
    setTimeout(function() {
      _MapControl.prototype.componentWillUnmount.call(_this5);
    }, 0);
  };
  _proto2.addBaseLayer = function addBaseLayer(layer, name, checked) {
    if (checked === void 0) {
      checked = false;
    }
    if (checked && this.props.leaflet.map != null) {
      this.props.leaflet.map.addLayer(layer);
    }
    this.leafletElement.addBaseLayer(layer, name);
  };
  _proto2.addOverlay = function addOverlay(layer, name, checked) {
    if (checked === void 0) {
      checked = false;
    }
    if (checked && this.props.leaflet.map != null) {
      this.props.leaflet.map.addLayer(layer);
    }
    this.leafletElement.addOverlay(layer, name);
  };
  _proto2.removeLayer = function removeLayer(layer) {
    if (this.props.leaflet.map != null) {
      this.props.leaflet.map.removeLayer(layer);
    }
  };
  _proto2.removeLayerControl = function removeLayerControl(layer) {
    this.leafletElement.removeLayer(layer);
  };
  _proto2.render = function render() {
    var _this6 = this;
    var children = import_react5.Children.map(this.props.children, function(child) {
      return child ? (0, import_react5.cloneElement)(child, _this6.controlProps) : null;
    });
    return import_react5.default.createElement(import_react5.Fragment, null, children);
  };
  return LayersControl2;
}(MapControl);
var LayersControlExport = withLeaflet(LayersControl);
LayersControlExport.BaseLayer = BaseLayer;
LayersControlExport.Overlay = Overlay;
var LayersControl_default = LayersControlExport;

// node_modules/react-leaflet/es/Map.js
init_extends();
init_objectWithoutPropertiesLoose();
init_assertThisInitialized();
init_inheritsLoose();
var import_leaflet12 = __toESM(require_leaflet_src());
var import_react6 = __toESM(require_react());

// node_modules/react-leaflet/es/utils/omit.js
function omit(obj) {
  for (var _len = arguments.length, keysToOmit = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keysToOmit[_key - 1] = arguments[_key];
  }
  return Object.keys(obj).reduce(function(acc, key) {
    if (keysToOmit.indexOf(key) === -1) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}

// node_modules/react-leaflet/es/Map.js
var OTHER_PROPS = ["children", "className", "id", "style", "useFlyTo", "whenReady"];
var normalizeCenter = function normalizeCenter2(pos) {
  return Array.isArray(pos) ? [pos[0], pos[1]] : [pos.lat, pos.lon ? pos.lon : pos.lng];
};
var Map = function(_MapEvented) {
  _inheritsLoose(Map2, _MapEvented);
  function Map2(props) {
    var _this;
    _this = _MapEvented.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this), "className", void 0);
    _defineProperty(_assertThisInitialized(_this), "contextValue", void 0);
    _defineProperty(_assertThisInitialized(_this), "container", void 0);
    _defineProperty(_assertThisInitialized(_this), "viewport", {
      center: void 0,
      zoom: void 0
    });
    _defineProperty(_assertThisInitialized(_this), "_ready", false);
    _defineProperty(_assertThisInitialized(_this), "_updating", false);
    _defineProperty(_assertThisInitialized(_this), "onViewportChange", function() {
      var center = _this.leafletElement.getCenter();
      _this.viewport = {
        center: center ? [center.lat, center.lng] : void 0,
        zoom: _this.leafletElement.getZoom()
      };
      if (_this.props.onViewportChange && !_this._updating) {
        _this.props.onViewportChange(_this.viewport);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onViewportChanged", function() {
      if (_this.props.onViewportChanged && !_this._updating) {
        _this.props.onViewportChanged(_this.viewport);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "bindContainer", function(container) {
      _this.container = container;
    });
    _this.className = props.className;
    return _this;
  }
  var _proto = Map2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var viewport = props.viewport, options = _objectWithoutPropertiesLoose(props, ["viewport"]);
    if (viewport) {
      if (viewport.center) {
        options.center = viewport.center;
      }
      if (typeof viewport.zoom === "number") {
        options.zoom = viewport.zoom;
      }
    }
    return new import_leaflet12.Map(this.container, options);
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    this._updating = true;
    var bounds = toProps.bounds, boundsOptions = toProps.boundsOptions, boxZoom = toProps.boxZoom, center = toProps.center, className = toProps.className, doubleClickZoom = toProps.doubleClickZoom, dragging = toProps.dragging, keyboard = toProps.keyboard, maxBounds = toProps.maxBounds, scrollWheelZoom = toProps.scrollWheelZoom, tap = toProps.tap, touchZoom = toProps.touchZoom, useFlyTo = toProps.useFlyTo, viewport = toProps.viewport, zoom = toProps.zoom;
    updateClassName_default(this.container, fromProps.className, className);
    if (viewport && viewport !== fromProps.viewport) {
      var c = viewport.center ? viewport.center : center;
      var z = viewport.zoom == null ? zoom : viewport.zoom;
      if (useFlyTo === true) {
        this.leafletElement.flyTo(c, z, this.getZoomPanOptions(toProps));
      } else {
        this.leafletElement.setView(c, z, this.getZoomPanOptions(toProps));
      }
    } else if (center && this.shouldUpdateCenter(center, fromProps.center)) {
      if (useFlyTo === true) {
        this.leafletElement.flyTo(center, zoom, this.getZoomPanOptions(toProps));
      } else {
        this.leafletElement.setView(center, zoom, this.getZoomPanOptions(toProps));
      }
    } else if (typeof zoom === "number" && zoom !== fromProps.zoom) {
      if (fromProps.zoom == null) {
        this.leafletElement.setView(center, zoom, this.getZoomPanOptions(toProps));
      } else {
        this.leafletElement.setZoom(zoom, this.getZoomPanOptions(toProps));
      }
    }
    if (maxBounds && this.shouldUpdateBounds(maxBounds, fromProps.maxBounds)) {
      this.leafletElement.setMaxBounds(maxBounds);
    }
    if (bounds && (this.shouldUpdateBounds(bounds, fromProps.bounds) || boundsOptions !== fromProps.boundsOptions)) {
      if (useFlyTo === true) {
        this.leafletElement.flyToBounds(bounds, this.getFitBoundsOptions(toProps));
      } else {
        this.leafletElement.fitBounds(bounds, this.getFitBoundsOptions(toProps));
      }
    }
    if (boxZoom !== fromProps.boxZoom) {
      if (boxZoom === true) {
        this.leafletElement.boxZoom.enable();
      } else {
        this.leafletElement.boxZoom.disable();
      }
    }
    if (doubleClickZoom !== fromProps.doubleClickZoom) {
      if (doubleClickZoom === true || typeof doubleClickZoom === "string") {
        this.leafletElement.options.doubleClickZoom = doubleClickZoom;
        this.leafletElement.doubleClickZoom.enable();
      } else {
        this.leafletElement.doubleClickZoom.disable();
      }
    }
    if (dragging !== fromProps.dragging) {
      if (dragging === true) {
        this.leafletElement.dragging.enable();
      } else {
        this.leafletElement.dragging.disable();
      }
    }
    if (keyboard !== fromProps.keyboard) {
      if (keyboard === true) {
        this.leafletElement.keyboard.enable();
      } else {
        this.leafletElement.keyboard.disable();
      }
    }
    if (scrollWheelZoom !== fromProps.scrollWheelZoom) {
      if (scrollWheelZoom === true || typeof scrollWheelZoom === "string") {
        this.leafletElement.options.scrollWheelZoom = scrollWheelZoom;
        this.leafletElement.scrollWheelZoom.enable();
      } else {
        this.leafletElement.scrollWheelZoom.disable();
      }
    }
    if (tap !== fromProps.tap) {
      if (tap === true) {
        this.leafletElement.tap.enable();
      } else {
        this.leafletElement.tap.disable();
      }
    }
    if (touchZoom !== fromProps.touchZoom) {
      if (touchZoom === true || typeof touchZoom === "string") {
        this.leafletElement.options.touchZoom = touchZoom;
        this.leafletElement.touchZoom.enable();
      } else {
        this.leafletElement.touchZoom.disable();
      }
    }
    this._updating = false;
  };
  _proto.getZoomPanOptions = function getZoomPanOptions(props) {
    var animate = props.animate, duration = props.duration, easeLinearity = props.easeLinearity, noMoveStart = props.noMoveStart;
    return {
      animate,
      duration,
      easeLinearity,
      noMoveStart
    };
  };
  _proto.getFitBoundsOptions = function getFitBoundsOptions(props) {
    var zoomPanOptions = this.getZoomPanOptions(props);
    return _extends({}, zoomPanOptions, props.boundsOptions);
  };
  _proto.componentDidMount = function componentDidMount() {
    var props = omit.apply(void 0, [this.props].concat(OTHER_PROPS));
    this.leafletElement = this.createLeafletElement(props);
    this.leafletElement.on("move", this.onViewportChange);
    this.leafletElement.on("moveend", this.onViewportChanged);
    if (props.bounds != null) {
      this.leafletElement.fitBounds(props.bounds, this.getFitBoundsOptions(props));
    }
    this.contextValue = {
      layerContainer: this.leafletElement,
      map: this.leafletElement
    };
    _MapEvented.prototype.componentDidMount.call(this);
    this.forceUpdate();
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this._ready === false) {
      this._ready = true;
      if (this.props.whenReady) {
        this.leafletElement.whenReady(this.props.whenReady);
      }
    }
    _MapEvented.prototype.componentDidUpdate.call(this, prevProps);
    this.updateLeafletElement(prevProps, this.props);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    _MapEvented.prototype.componentWillUnmount.call(this);
    this.leafletElement.off("move", this.onViewportChange);
    this.leafletElement.off("moveend", this.onViewportChanged);
    if (this.props.preferCanvas === true) {
      this.leafletElement._initEvents(true);
      this.leafletElement._stop();
    } else {
      this.leafletElement.remove();
    }
  };
  _proto.shouldUpdateCenter = function shouldUpdateCenter(next, prev) {
    if (!prev)
      return true;
    next = normalizeCenter(next);
    prev = normalizeCenter(prev);
    return next[0] !== prev[0] || next[1] !== prev[1];
  };
  _proto.shouldUpdateBounds = function shouldUpdateBounds(next, prev) {
    return prev ? !(0, import_leaflet12.latLngBounds)(next).equals((0, import_leaflet12.latLngBounds)(prev)) : true;
  };
  _proto.render = function render() {
    return import_react6.default.createElement("div", {
      className: this.className,
      id: this.props.id,
      ref: this.bindContainer,
      style: this.props.style
    }, this.contextValue ? import_react6.default.createElement(LeafletProvider, {
      value: this.contextValue
    }, this.props.children) : null);
  };
  return Map2;
}(MapEvented);

// node_modules/react-leaflet/es/Marker.js
init_extends();
init_inheritsLoose();
var import_leaflet13 = __toESM(require_leaflet_src());
var import_react7 = __toESM(require_react());
var Marker = function(_MapLayer) {
  _inheritsLoose(Marker2, _MapLayer);
  function Marker2() {
    return _MapLayer.apply(this, arguments) || this;
  }
  var _proto = Marker2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var el = new import_leaflet13.Marker(props.position, this.getOptions(props));
    this.contextValue = _extends({}, props.leaflet, {
      popupContainer: el
    });
    return el;
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.position !== fromProps.position) {
      this.leafletElement.setLatLng(toProps.position);
    }
    if (toProps.icon !== fromProps.icon) {
      this.leafletElement.setIcon(toProps.icon);
    }
    if (toProps.zIndexOffset !== fromProps.zIndexOffset) {
      this.leafletElement.setZIndexOffset(toProps.zIndexOffset);
    }
    if (toProps.opacity !== fromProps.opacity) {
      this.leafletElement.setOpacity(toProps.opacity);
    }
    if (toProps.draggable !== fromProps.draggable) {
      if (toProps.draggable === true) {
        this.leafletElement.dragging.enable();
      } else {
        this.leafletElement.dragging.disable();
      }
    }
  };
  _proto.render = function render() {
    var children = this.props.children;
    return children == null || this.contextValue == null ? null : import_react7.default.createElement(LeafletProvider, {
      value: this.contextValue
    }, children);
  };
  return Marker2;
}(MapLayer);
var Marker_default = withLeaflet(Marker);

// node_modules/react-leaflet/es/Pane.js
init_extends();
init_assertThisInitialized();
init_inheritsLoose();
var import_react8 = __toESM(require_react());
var import_warning = __toESM(require_warning());
var idCounter = 0;
var uniqueId = function uniqueId2() {
  return ++idCounter;
};
var LEAFLET_PANES = ["tile", "shadow", "overlay", "map", "marker", "tooltip", "popup"];
var PANE_RE = /-*pane/gi;
var isLeafletPane = function isLeafletPane2(name) {
  return LEAFLET_PANES.indexOf(name.replace(PANE_RE, "")) !== -1;
};
var paneStyles = {
  position: "absolute",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var Pane = function(_Component) {
  _inheritsLoose(Pane2, _Component);
  function Pane2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _defineProperty(_assertThisInitialized(_this), "state", {
      name: void 0,
      context: void 0
    });
    _defineProperty(_assertThisInitialized(_this), "setStyle", function(_temp) {
      var _ref = _temp === void 0 ? _this.props : _temp, style = _ref.style, className = _ref.className;
      var pane = _this.getPane(_this.state.name);
      if (pane) {
        if (className) {
          addClassName(pane, className);
        }
        if (style) {
          Object.keys(style).forEach(function(key) {
            pane.style[key] = style[key];
          });
        }
      }
    });
    return _this;
  }
  var _proto = Pane2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.createPane(this.props);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (!this.state.name) {
      return;
    }
    if (this.props.name !== prevProps.name) {
      this.removePane();
      this.createPane(this.props);
    } else {
      if (prevProps.className && this.props.className !== prevProps.className) {
        var pane = this.getPane(this.state.name);
        if (pane != null && prevProps.className != null) {
          removeClassName(pane, prevProps.className);
        }
      }
      this.setStyle(this.props);
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.removePane();
  };
  _proto.createPane = function createPane(props) {
    var map = props.leaflet.map;
    var name = props.name || "pane-" + uniqueId();
    if (map != null && map.createPane != null) {
      var isDefault = isLeafletPane(name);
      var existing = isDefault || this.getPane(name);
      if (existing == null) {
        map.createPane(name, this.getParentPane());
      } else {
        var message = isDefault ? "You must use a unique name for a pane that is not a default leaflet pane (" + name + ")" : "A pane with this name already exists. (" + name + ")";
        true ? (0, import_warning.default)(false, message) : void 0;
      }
      this.setState({
        name,
        context: _extends({}, props.leaflet, {
          pane: name
        })
      }, this.setStyle);
    }
  };
  _proto.removePane = function removePane() {
    var name = this.state.name;
    if (name != null) {
      var pane = this.getPane(name);
      if (pane != null && pane.remove)
        pane.remove();
      var map = this.props.leaflet.map;
      if (map != null && map._panes != null) {
        map._panes = omit(map._panes, name);
        map._paneRenderers = omit(map._paneRenderers, name);
      }
    }
  };
  _proto.getParentPane = function getParentPane() {
    return this.getPane(this.props.pane || this.props.leaflet.pane);
  };
  _proto.getPane = function getPane(name) {
    if (name != null && this.props.leaflet.map != null) {
      return this.props.leaflet.map.getPane(name);
    }
  };
  _proto.render = function render() {
    var context = this.state.context;
    return context ? import_react8.default.createElement(LeafletProvider, {
      value: context
    }, import_react8.default.createElement("div", {
      style: paneStyles
    }, this.props.children)) : null;
  };
  return Pane2;
}(import_react8.Component);
var Pane_default = withLeaflet(Pane);

// node_modules/react-leaflet/es/Polygon.js
init_inheritsLoose();
var import_leaflet14 = __toESM(require_leaflet_src());
var Polygon = function(_Path) {
  _inheritsLoose(Polygon2, _Path);
  function Polygon2() {
    return _Path.apply(this, arguments) || this;
  }
  var _proto = Polygon2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet14.Polygon(props.positions, this.getOptions(props));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.positions !== fromProps.positions) {
      this.leafletElement.setLatLngs(toProps.positions);
    }
    this.setStyleIfChanged(fromProps, toProps);
  };
  return Polygon2;
}(Path);
var Polygon_default = withLeaflet(Polygon);

// node_modules/react-leaflet/es/Polyline.js
init_inheritsLoose();
var import_leaflet15 = __toESM(require_leaflet_src());
var Polyline = function(_Path) {
  _inheritsLoose(Polyline2, _Path);
  function Polyline2() {
    return _Path.apply(this, arguments) || this;
  }
  var _proto = Polyline2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet15.Polyline(props.positions, this.getOptions(props));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.positions !== fromProps.positions) {
      this.leafletElement.setLatLngs(toProps.positions);
    }
    this.setStyleIfChanged(fromProps, toProps);
  };
  return Polyline2;
}(Path);
var Polyline_default = withLeaflet(Polyline);

// node_modules/react-leaflet/es/Popup.js
init_extends();
init_assertThisInitialized();
init_inheritsLoose();
var import_leaflet16 = __toESM(require_leaflet_src());
var Popup = function(_DivOverlay) {
  _inheritsLoose(Popup2, _DivOverlay);
  function Popup2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _DivOverlay.call.apply(_DivOverlay, [this].concat(args)) || this;
    _defineProperty(_assertThisInitialized(_this), "onPopupOpen", function(_ref) {
      var popup = _ref.popup;
      if (popup === _this.leafletElement) {
        _this.onOpen();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onPopupClose", function(_ref2) {
      var popup = _ref2.popup;
      if (popup === _this.leafletElement) {
        _this.onClose();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onRender", function() {
      if (_this.props.autoPan !== false && _this.leafletElement.isOpen()) {
        if (_this.leafletElement._map && _this.leafletElement._map._panAnim) {
          _this.leafletElement._map._panAnim = void 0;
        }
        _this.leafletElement._adjustPan();
      }
    });
    return _this;
  }
  var _proto = Popup2.prototype;
  _proto.getOptions = function getOptions(props) {
    return _extends({}, _DivOverlay.prototype.getOptions.call(this, props), {
      autoPan: false
    });
  };
  _proto.createLeafletElement = function createLeafletElement(props) {
    var options = this.getOptions(props);
    options.autoPan = props.autoPan !== false;
    return new import_leaflet16.Popup(options, props.leaflet.popupContainer);
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.position !== fromProps.position) {
      this.leafletElement.setLatLng(toProps.position);
    }
  };
  _proto.componentDidMount = function componentDidMount() {
    var position = this.props.position;
    var _this$props$leaflet = this.props.leaflet, map = _this$props$leaflet.map, popupContainer = _this$props$leaflet.popupContainer;
    var el = this.leafletElement;
    if (map != null) {
      map.on({
        popupopen: this.onPopupOpen,
        popupclose: this.onPopupClose
      });
    }
    if (popupContainer) {
      popupContainer.bindPopup(el);
    } else {
      if (position) {
        el.setLatLng(position);
      }
      el.openOn(map);
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    var map = this.props.leaflet.map;
    if (map != null) {
      map.off({
        popupopen: this.onPopupOpen,
        popupclose: this.onPopupClose
      });
      map.removeLayer(this.leafletElement);
    }
    _DivOverlay.prototype.componentWillUnmount.call(this);
  };
  return Popup2;
}(DivOverlay);
_defineProperty(Popup, "defaultProps", {
  pane: "popupPane"
});
var Popup_default = withLeaflet(Popup);

// node_modules/react-leaflet/es/Rectangle.js
init_inheritsLoose();
var import_leaflet17 = __toESM(require_leaflet_src());
var Rectangle = function(_Path) {
  _inheritsLoose(Rectangle2, _Path);
  function Rectangle2() {
    return _Path.apply(this, arguments) || this;
  }
  var _proto = Rectangle2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet17.Rectangle(props.bounds, this.getOptions(props));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.bounds !== fromProps.bounds) {
      this.leafletElement.setBounds(toProps.bounds);
    }
    this.setStyleIfChanged(fromProps, toProps);
  };
  return Rectangle2;
}(Path);
var Rectangle_default = withLeaflet(Rectangle);

// node_modules/react-leaflet/es/ScaleControl.js
init_inheritsLoose();
var import_leaflet18 = __toESM(require_leaflet_src());
var ScaleControl = function(_MapControl) {
  _inheritsLoose(ScaleControl2, _MapControl);
  function ScaleControl2() {
    return _MapControl.apply(this, arguments) || this;
  }
  var _proto = ScaleControl2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet18.Control.Scale(props);
  };
  return ScaleControl2;
}(MapControl);
var ScaleControl_default = withLeaflet(ScaleControl);

// node_modules/react-leaflet/es/SVGOverlay.js
init_assertThisInitialized();
init_inheritsLoose();
var import_leaflet19 = __toESM(require_leaflet_src());
var import_react_dom2 = __toESM(require_react_dom());
function setAttribute(el, name, value) {
  if (value != null) {
    el.setAttribute(name, value);
  } else {
    el.removeAttribute(name);
  }
}
var SVGOverlay = function(_MapComponent) {
  _inheritsLoose(SVGOverlay2, _MapComponent);
  function SVGOverlay2(props) {
    var _this;
    _this = _MapComponent.call(this, props) || this;
    _defineProperty(_assertThisInitialized(_this), "leafletElement", void 0);
    _defineProperty(_assertThisInitialized(_this), "container", void 0);
    _this.leafletElement = _this.createLeafletElement(props);
    return _this;
  }
  var _proto = SVGOverlay2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var container = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    setAttribute(container, "xmlns", "http://www.w3.org/2000/svg");
    setAttribute(container, "preserveAspectRatio", props.preserveAspectRatio);
    setAttribute(container, "viewBox", props.viewBox);
    this.container = container;
    return new import_leaflet19.SVGOverlay(container, props.bounds, this.getOptions(props));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.bounds !== fromProps.bounds) {
      this.leafletElement.setBounds(toProps.bounds);
    }
    if (toProps.opacity !== fromProps.opacity) {
      this.leafletElement.setOpacity(toProps.opacity);
    }
    if (this.container && toProps.preserveAspectRatio !== fromProps.preserveAspectRatio) {
      setAttribute(this.container, "preserveAspectRatio", toProps.preserveAspectRatio);
    }
    if (this.container && toProps.viewBox !== fromProps.viewBox) {
      setAttribute(this.container, "viewBox", toProps.viewBox);
    }
    if (toProps.zIndex !== fromProps.zIndex) {
      this.leafletElement.setZIndex(toProps.zIndex);
    }
  };
  _proto.componentDidMount = function componentDidMount() {
    _MapComponent.prototype.componentDidMount.call(this);
    this.layerContainer.addLayer(this.leafletElement);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    _MapComponent.prototype.componentDidUpdate.call(this, prevProps);
    if (this.props.attribution !== prevProps.attribution) {
      var map = this.props.leaflet.map;
      if (map != null && map.attributionControl != null) {
        map.attributionControl.removeAttribution(prevProps.attribution);
        map.attributionControl.addAttribution(this.props.attribution);
      }
    }
    this.updateLeafletElement(prevProps, this.props);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    _MapComponent.prototype.componentWillUnmount.call(this);
    this.layerContainer.removeLayer(this.leafletElement);
    this.container = null;
  };
  _proto.render = function render() {
    var children = this.props.children;
    if (children == null || this.container == null) {
      return null;
    }
    return (0, import_react_dom2.createPortal)(children, this.container);
  };
  _createClass(SVGOverlay2, [{
    key: "layerContainer",
    get: function get() {
      return this.props.leaflet.layerContainer || this.props.leaflet.map;
    }
  }]);
  return SVGOverlay2;
}(MapComponent);
var SVGOverlay_default = withLeaflet(SVGOverlay);

// node_modules/react-leaflet/es/TileLayer.js
init_inheritsLoose();
var import_leaflet20 = __toESM(require_leaflet_src());
var TileLayer = function(_GridLayer) {
  _inheritsLoose(TileLayer3, _GridLayer);
  function TileLayer3() {
    return _GridLayer.apply(this, arguments) || this;
  }
  var _proto = TileLayer3.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet20.TileLayer(props.url, this.getOptions(props));
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    _GridLayer.prototype.updateLeafletElement.call(this, fromProps, toProps);
    if (toProps.url !== fromProps.url) {
      this.leafletElement.setUrl(toProps.url);
    }
  };
  return TileLayer3;
}(GridLayer);
var TileLayer_default = withLeaflet(TileLayer);

// node_modules/react-leaflet/es/Tooltip.js
init_assertThisInitialized();
init_inheritsLoose();
var import_leaflet21 = __toESM(require_leaflet_src());
var Tooltip = function(_DivOverlay) {
  _inheritsLoose(Tooltip2, _DivOverlay);
  function Tooltip2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _DivOverlay.call.apply(_DivOverlay, [this].concat(args)) || this;
    _defineProperty(_assertThisInitialized(_this), "onTooltipOpen", function(_ref) {
      var tooltip = _ref.tooltip;
      if (tooltip === _this.leafletElement) {
        _this.onOpen();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onTooltipClose", function(_ref2) {
      var tooltip = _ref2.tooltip;
      if (tooltip === _this.leafletElement) {
        _this.onClose();
      }
    });
    return _this;
  }
  var _proto = Tooltip2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet21.Tooltip(this.getOptions(props), props.leaflet.popupContainer);
  };
  _proto.componentDidMount = function componentDidMount() {
    var popupContainer = this.props.leaflet.popupContainer;
    if (popupContainer == null)
      return;
    popupContainer.on({
      tooltipopen: this.onTooltipOpen,
      tooltipclose: this.onTooltipClose
    });
    popupContainer.bindTooltip(this.leafletElement);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    var popupContainer = this.props.leaflet.popupContainer;
    if (popupContainer == null)
      return;
    popupContainer.off({
      tooltipopen: this.onTooltipOpen,
      tooltipclose: this.onTooltipClose
    });
    if (popupContainer._map != null) {
      popupContainer.unbindTooltip(this.leafletElement);
    }
  };
  return Tooltip2;
}(DivOverlay);
_defineProperty(Tooltip, "defaultProps", {
  pane: "tooltipPane"
});
var Tooltip_default = withLeaflet(Tooltip);

// node_modules/react-leaflet/es/VideoOverlay.js
init_inheritsLoose();
var import_leaflet22 = __toESM(require_leaflet_src());
var VideoOverlay = function(_MapLayer) {
  _inheritsLoose(VideoOverlay2, _MapLayer);
  function VideoOverlay2() {
    return _MapLayer.apply(this, arguments) || this;
  }
  var _proto = VideoOverlay2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet22.VideoOverlay(props.url, props.bounds, this.getOptions(props));
  };
  _proto.componentDidMount = function componentDidMount() {
    _MapLayer.prototype.componentDidMount.call(this);
    if (this.props.play === true) {
      this.leafletElement.getElement().play();
    }
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    if (toProps.url !== fromProps.url) {
      this.leafletElement.setUrl(toProps.url);
    }
    if (toProps.bounds !== fromProps.bounds) {
      this.leafletElement.setBounds((0, import_leaflet22.latLngBounds)(toProps.bounds));
    }
    if (toProps.opacity !== fromProps.opacity) {
      this.leafletElement.setOpacity(toProps.opacity);
    }
    if (toProps.zIndex !== fromProps.zIndex) {
      this.leafletElement.setZIndex(toProps.zIndex);
    }
    if (toProps.play === true && !fromProps.play) {
      this.leafletElement.getElement().play();
    } else if (!toProps.play && fromProps.play === true) {
      this.leafletElement.getElement().pause();
    }
  };
  return VideoOverlay2;
}(MapLayer);
var VideoOverlay_default = withLeaflet(VideoOverlay);

// node_modules/react-leaflet/es/WMSTileLayer.js
init_objectWithoutPropertiesLoose();
init_inheritsLoose();
var import_leaflet23 = __toESM(require_leaflet_src());
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal());
var WMSTileLayer = function(_GridLayer) {
  _inheritsLoose(WMSTileLayer2, _GridLayer);
  function WMSTileLayer2() {
    return _GridLayer.apply(this, arguments) || this;
  }
  var _proto = WMSTileLayer2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    var url = props.url, params = _objectWithoutPropertiesLoose(props, ["url"]);
    var _this$getOptions = this.getOptions(params), _l = _this$getOptions.leaflet, options = _objectWithoutPropertiesLoose(_this$getOptions, ["leaflet"]);
    return new import_leaflet23.TileLayer.WMS(url, options);
  };
  _proto.updateLeafletElement = function updateLeafletElement(fromProps, toProps) {
    _GridLayer.prototype.updateLeafletElement.call(this, fromProps, toProps);
    var prevUrl = fromProps.url, _po = fromProps.opacity, _pz = fromProps.zIndex, prevProps = _objectWithoutPropertiesLoose(fromProps, ["url", "opacity", "zIndex"]);
    var _this$getOptions2 = this.getOptions(prevProps), _pl = _this$getOptions2.leaflet, prevParams = _objectWithoutPropertiesLoose(_this$getOptions2, ["leaflet"]);
    var url = toProps.url, _o = toProps.opacity, _z = toProps.zIndex, props = _objectWithoutPropertiesLoose(toProps, ["url", "opacity", "zIndex"]);
    var _this$getOptions3 = this.getOptions(props), _l = _this$getOptions3.leaflet, params = _objectWithoutPropertiesLoose(_this$getOptions3, ["leaflet"]);
    if (url !== prevUrl) {
      this.leafletElement.setUrl(url);
    }
    if (!(0, import_fast_deep_equal2.default)(params, prevParams)) {
      this.leafletElement.setParams(params);
    }
  };
  _proto.getOptions = function getOptions(params) {
    var superOptions = _GridLayer.prototype.getOptions.call(this, params);
    return Object.keys(superOptions).reduce(function(options, key) {
      if (!EVENTS_RE.test(key)) {
        options[key] = superOptions[key];
      }
      return options;
    }, {});
  };
  return WMSTileLayer2;
}(GridLayer);
var WMSTileLayer_default = withLeaflet(WMSTileLayer);

// node_modules/react-leaflet/es/ZoomControl.js
init_inheritsLoose();
var import_leaflet24 = __toESM(require_leaflet_src());
var ZoomControl = function(_MapControl) {
  _inheritsLoose(ZoomControl2, _MapControl);
  function ZoomControl2() {
    return _MapControl.apply(this, arguments) || this;
  }
  var _proto = ZoomControl2.prototype;
  _proto.createLeafletElement = function createLeafletElement(props) {
    return new import_leaflet24.Control.Zoom(props);
  };
  return ZoomControl2;
}(MapControl);
var ZoomControl_default = withLeaflet(ZoomControl);
export {
  AttributionControl_default as AttributionControl,
  Circle_default as Circle,
  CircleMarker_default as CircleMarker,
  ControlledLayer,
  DivOverlay,
  FeatureGroup_default as FeatureGroup,
  GeoJSON_default as GeoJSON,
  GridLayer,
  ImageOverlay_default as ImageOverlay,
  LayerGroup_default as LayerGroup,
  LayersControl_default as LayersControl,
  LeafletConsumer,
  LeafletProvider,
  Map,
  MapComponent,
  MapControl,
  MapEvented,
  MapLayer,
  Marker_default as Marker,
  Pane_default as Pane,
  Path,
  Polygon_default as Polygon,
  Polyline_default as Polyline,
  Popup_default as Popup,
  Rectangle_default as Rectangle,
  SVGOverlay_default as SVGOverlay,
  ScaleControl_default as ScaleControl,
  TileLayer_default as TileLayer,
  Tooltip_default as Tooltip,
  VideoOverlay_default as VideoOverlay,
  WMSTileLayer_default as WMSTileLayer,
  ZoomControl_default as ZoomControl,
  useLeaflet,
  withLeaflet
};
//# sourceMappingURL=react-leaflet.js.map
